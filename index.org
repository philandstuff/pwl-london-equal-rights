#+TITLE: Equal Rights for Functional Objects
#+AUTHOR: Henry Baker
#+EMAIL: Philip Potter - @philandstuff
#+OPTIONS: reveal_mathjax:t reveal_history:t num:nil
#+REVEAL_HLEVEL:1
#+REVEAL_MIN_SCALE:1.2
#+REVEAL_MAX_SCALE:1.2
#+REVEAL_ROOT:.
#+REVEAL_TRANS:linear
#+REVEAL_THEME:simple

* introduction

#+ATTR_REVEAL: :frag t
  The Joy of Clojure, Michael Fogus and Chris Houser

#+ATTR_REVEAL: :frag t
  /And if two objects aren't equal forever, then they're technically
  never equal (Baker 1993)./

* problem: many types of equality

#+ATTR_HTML: :class reveal
| C++       | pointer equality, overloaded ~==~ operator            |
| Lisp      | ~EQ~, ~EQL~, ~EQUAL~, ~EQUALP~, ~STRING=~, ~CHAR=~... |
| Smalltalk | ~=~, ~==~                                             |
| Java      | ~==~, ~.equals()~                                     |
| Perl      | ~==~, ~eq~                                            |
| Python    | ~==~, ~is~                                            |
| Ruby      | ~==~, ~eql?~, ~equal?~                                |

** oops

#+BEGIN_SRC python :exports both :session
  # Python
  x = 1
  y = 1
  x is y
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC python :exports both :session
  x = 500
  y = 500
  x is y
#+END_SRC

#+RESULTS:
: False

** oops

#+BEGIN_SRC java
  public class Foo {
      public static void main(String[] args) {
          if (Integer.valueOf(200) == Integer.valueOf(200)) {
              System.out.println("Hooray!");
          } else {
              System.out.println("Oh noes!");
          }
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
Oh noes!
#+END_EXAMPLE

** lists

   if x = ~[1,2,3]~, and y = ~[1,2,3]~:

   are they equal?

   are they the same?

#+ATTR_REVEAL: :frag t
   can we answer this without resorting to "it depends"?

** in java.util.List terms...

   - ~==~ is sometimes too fine
   - ~.equals()~ is sometimes too coarse


* object identity

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC ruby
  sugababes = Set.new [:mutya, :keisha, :siobhan]
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC ruby
  sugababes.delete(:siobhan); sugababes.add(:heidi) # 2001
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC ruby
  sugababes.delete(:mutya); sugababes.add(:amelle) # 2005
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC ruby
  sugababes.delete(:keisha); sugababes.add(:jade) # 2009
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC ruby
  new_band = Set.new [:mutya, :keisha, :siobhan] # 2011
#+END_SRC

* what do we really want from equality?

** ONE equality operator!

** equivalence relation

reflexive:

$$ a \equiv a $$

symmetric:

$$ a \equiv b \implies b \equiv a $$

transitive:

$$ a \equiv b \land b \equiv c \implies a \equiv c $$

Partitions the universe into /equivalence classes/

#+REVEAL: split

$x \equiv y \implies f(x) \equiv f(y)$

for arbitrary $f$

** not too fine, not too coarse

* solution: egal

  Key idea is that of object identity:

  Objects which /behave/ the same should /be/ the same.

#+ATTR_REVEAL: :frag t
  Related to "identity of indiscernibles"

** numbers

   500 = 500

   not a lot more to it.

** immutable lists

   [1,2,3] = [1,2,3]

#+ATTR_REVEAL: :frag t

   more generally, iterate over elements and recursively call egal

** mutable lists

   [1,2,3] = [1,2,3]?

** mutable lists

compare ~eq-cons~ on p3 of the paper

#+BEGIN_SRC ruby :exports both :results output
  def same?(x,y)
    saved_head = x[0]
    x[0] = "My super-sekrit value"
    x[0] == y[0]
  ensure
    x[0] = saved_head
  end

  x = ["a"]; y = ["a"]

  puts "x=x: #{same?(x,x)}"
  puts "x=y: #{same?(x,y)}"
#+END_SRC

#+RESULTS:
: x=x: true
: x=y: false

** examples

*** mutable objects

*** immutable objects

*** immutable objects with references to mutable components
* implications
** immutability matters

*** immutable views on mutable objects don't cut it

** mutable lists & sets are rubbish

*** lose much of the utility of having a compound if you can't easily compare it
* questions for discussion
** reference equality isn't perfect for mutable objects

#+BEGIN_NOTES
conflict: can't have reference equality and the ability to simulate other objects
#+END_NOTES

** laziness
** abstract data types & user-defined equality
*** classic problem with cached hashcode field as a perf optimization
** closures and data defined using them
*** applies equally to anonymous inner classes
* what is the problem?
  Why does equality matter?

** too fine a distinction? too coarse?

   numbers -- EQ

   strings

   "~EQ~ is often too fine, and ~EQUAL~ is often too coarse"

   equality of lists, sets, maps

** map lookup

   map lookup depends on your equality relation

   in Lisp, you need ~EQL~ for numbers but ~EQUAL~ for strings

   this prevents the creation of a single map that takes arbitrary
   keys

   (useful for generic memoizing function)

** reference equality
   do ~x~ and ~y~ refer to the same location (i.e. object) in memory?

   (this doesn't even make sense for some ~x~ and ~y~, such as
   primitive ~int~ and ~float~ values)
** value equality
   do ~x~ and ~y~ have the same value?

#+ATTR_REVEAL: :frag t
   (at this moment in time)?

** bitwise equality
   reference equality for pointers

   value equality for primitive types

   Java's ~==~, Lisp's ~EQ~, Ruby's ~equal?~

#+ATTR_REVEAL: :frag t
   efficiently maps to native machine instructions

#+ATTR_REVEAL: :frag t
   semantically problematic

** user-defined equality
   give every object an ~equal~ method that the user can override
** operational equivalence
   can I distinguish ~x~ and ~y~ by calling methods on them?

   /extensional equivalence/

   (oppose /intensional equivalence/)

   black box vs white box
** identity of indiscernables
   If there's no way to tell the difference between $x$ and $y$, then
   $x = y$
#+ATTR_REVEAL: :frag t   
   if $x$ is a pink unicorn and $y$ is a green unicorn, they are not
   the same, because $x$ is pink and $y$ is not pink
#+ATTR_REVEAL: :frag t
what about the /invisible pink unicorn/?

#+BEGIN_NOTES
(we know that she is invisible, because we can't see her; we have faith that she is pink)

the invisible pink unicorn is indiscernible from the invisible green unicorn

therefore, they are the same thing
#+END_NOTES

** pedagogical example

* aside: equivalence relation

** symmetry causes particular problems for inheritance

If $B$ is a subclass of $A$, and $A \equiv B$, does $B \equiv A$?
