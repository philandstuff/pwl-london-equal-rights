<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Equal Rights for Functional Objects</title>
<meta name="author" content="(Henry Baker)"/>
<link rel="stylesheet" href="./css/reveal.min.css"/>
<link rel="stylesheet" href="./css/theme/simple.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<h1>Equal Rights for Functional Objects</h1>
<h2>Henry Baker</h2>
<h2><a href="mailto:Philip Potter - @philandstuff">Philip Potter - @philandstuff</a></h2>
<h2></h2></section>
<section>
<h2>Table of Contents</h2><ul>
<li>
<a href="#sec-1">introduction</a>
<ul>
<li>
<a href="#sec-1-1">how did I find this paper?</a>
</li>
<li>
<a href="#sec-1-2">why do I love this paper?</a>
</li>
<li>
<a href="#sec-1-3">why do I love this paper?</a>
</li>
</ul>
<li>
<a href="#sec-2">problem: many types of equality</a>
<ul>
<li>
<a href="#sec-2-1">oops</a>
</li>
<li>
<a href="#sec-2-2">oops</a>
</li>
<li>
<a href="#sec-2-3">lists</a>
</li>
<li>
<a href="#sec-2-4">reference equality</a>
</li>
<li>
<a href="#sec-2-5">reference equality?</a>
</li>
</ul>
<li>
<a href="#sec-3">oo semantics and object identity</a>
</li>
<li>
<a href="#sec-4">what do we really want from equality?</a>
<ul>
<li>
<a href="#sec-4-1">ONE equality operator!</a>
</li>
<li>
<a href="#sec-4-2">equivalence relation</a>
</li>
<li>
<a href="#sec-4-3">x=y =&gt; f(x)=f(y) for arbitrary f</a>
</li>
<li>
<a href="#sec-4-4">useful &amp; important to be able to compare compound values</a>
</li>
<li>
<a href="#sec-4-5">useful &amp; important to distinguish different objects with same current value</a>
</li>
<li>
<a href="#sec-4-6">useful &amp; important to have a single equality predicate to perform these jobs</a>
</li>
<li>
<a href="#sec-4-7">in java.util.List terms&#x2026;</a>
</li>
</ul>
<li>
<a href="#sec-5">solution: egal</a>
<ul>
<li>
<a href="#sec-5-1">works everywhere</a>
</li>
<li>
<a href="#sec-5-2">examples</a>
<ul>
<li>
<a href="#sec-5-2-1">mutable objects</a>
</li>
<li>
<a href="#sec-5-2-2">immutable objects</a>
</li>
<li>
<a href="#sec-5-2-3">immutable objects with references to mutable components</a>
</li>
</ul>
<li>
<a href="#sec-6">implications</a>
<ul>
<li>
<a href="#sec-6-1">immutability matters</a>
<ul>
<li>
<a href="#sec-6-1-1">immutable views on mutable objects don't cut it</a>
</li>
</ul>
<li>
<a href="#sec-6-2">mutable lists &amp; sets are rubbish</a>
<ul>
<li>
<a href="#sec-6-2-1">lose much of the utility of having a compound if you can't easily compare it</a>
</li>
</ul>
<li>
<a href="#sec-7">questions for discussion</a>
<ul>
<li>
<a href="#sec-7-1">reference equality isn't perfect for mutable objects</a>
</li>
<li>
<a href="#sec-7-2">laziness</a>
</li>
<li>
<a href="#sec-7-3">abstract data types &amp; user-defined equality</a>
<ul>
<li>
<a href="#sec-7-3-1">classic problem with cached hashcode field as a perf optimization</a>
</li>
</ul>
<li>
<a href="#sec-7-4">closures and data defined using them</a>
<ul>
<li>
<a href="#sec-7-4-1">applies equally to anonymous inner classes</a>
</li>
</ul>
<li>
<a href="#sec-8">what is the problem?</a>
<ul>
<li>
<a href="#sec-8-1">too fine a distinction? too coarse?</a>
</li>
<li>
<a href="#sec-8-2">map lookup</a>
</li>
<li>
<a href="#sec-8-3">reference equality</a>
</li>
<li>
<a href="#sec-8-4">value equality</a>
</li>
<li>
<a href="#sec-8-5">bitwise equality</a>
</li>
<li>
<a href="#sec-8-6">user-defined equality</a>
</li>
<li>
<a href="#sec-8-7">operational equivalence</a>
</li>
<li>
<a href="#sec-8-8">identity of indiscernables</a>
</li>
<li>
<a href="#sec-8-9">pedagogical example</a>
</li>
</ul>
<li>
<a href="#sec-9">aside: equivalence relation</a>
<ul>
<li>
<a href="#sec-9-1">symmetry causes particular problems for inheritance</a>
</li>
</ul>
</section>

<section>
<section id="sec-1" >

<h2>introduction</h2>
</section>
<section id="sec-1-1" >

<h3>how did I find this paper?</h3>

</section>
<section id="sec-1-2" >

<h3>why do I love this paper?</h3>
<p>
It's well written and clear
</p>

<p>
It has one core idea that it explores in hundreds of examples
</p>

</section>
<section id="sec-1-3" >

<h3>why do I love this paper?</h3>
<p>
It's about languages with OO and FP aspects
</p>

<p>
it was an interesting time &#x2013; before most languages we use today were invented
</p>
</section>

</section>
<section>
<section id="sec-2" >

<h2>problem: many types of equality</h2>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="reveal">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">C++</td>
<td class="left">pointer equality, overloaded <code>==</code> operator</td>
</tr>

<tr>
<td class="left">Lisp</td>
<td class="left"><code>EQ</code>, <code>EQL</code>, <code>EQUAL</code>, <code>EQUALP</code>, <code>STRING=</code>, <code>CHAR=</code>&#x2026;</td>
</tr>

<tr>
<td class="left">Smalltalk</td>
<td class="left"><code>=</code>, <code>==</code></td>
</tr>

<tr>
<td class="left">Java</td>
<td class="left"><code>==</code>, <code>.equals()</code></td>
</tr>

<tr>
<td class="left">Perl</td>
<td class="left"><code>==</code>, <code>eq</code></td>
</tr>

<tr>
<td class="left">Python</td>
<td class="left"><code>==</code>, <code>is</code></td>
</tr>

<tr>
<td class="left">Ruby</td>
<td class="left"><code>==</code>, <code>eql?</code>, <code>equal?</code></td>
</tr>
</tbody>
</table>

</section>
<section id="sec-2-1" >

<h3>oops</h3>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #b22222;"># </span><span style="color: #b22222;">Python</span>
<span style="color: #a0522d;">x</span> = 1
<span style="color: #a0522d;">y</span> = 1
x <span style="color: #a020f0;">is</span> y
</pre>
</div>

<pre class="example">
True
</pre>

<div class="org-src-container">

<pre  class="src src-python"><span style="color: #a0522d;">x</span> = 50001
<span style="color: #a0522d;">y</span> = 50001
x <span style="color: #a020f0;">is</span> y
</pre>
</div>

<pre class="example">
False
</pre>

</section>
<section id="sec-2-2" >

<h3>oops</h3>
<div class="org-src-container">

<pre  class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Foo</span> {
    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">String</span>[] <span style="color: #a0522d;">args</span>) {
        <span style="color: #a020f0;">if</span> (Integer.valueOf(200) == Integer.valueOf(200)) {
            System.out.println(<span style="color: #8b2252;">"Hooray!"</span>);
        } <span style="color: #a020f0;">else</span> {
            System.out.println(<span style="color: #8b2252;">"Oh noes!"</span>);
        }
    }
}
</pre>
</div>

<pre class="example">
Oh noes!
</pre>

</section>
<section id="sec-2-3" >

<h3>lists</h3>
<p>
if x = <code>[1,2,3]</code>, and y = <code>[1,2,3]</code>:
</p>

<p>
are they equal?
</p>

<p>
are they the same?
</p>

<p class="fragment">
can we answer this without resorting to "it depends"?
</p>

</section>
<section id="sec-2-4" >

<h3>reference equality</h3>

</section>
<section id="sec-2-5" >

<h3>reference equality?</h3>
<p>
(see <code>eq-cons</code> on p3 of the paper)
</p>

<div class="org-src-container">

<pre  class="src src-ruby"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">same?</span>(x,y)
  saved_head = x[0]
  x[0] = <span style="color: #228b22;">BasicObject</span>.new
  x[0] == y[0]
<span style="color: #a020f0;">ensure</span>
  x[0] = saved_head
<span style="color: #a020f0;">end</span>

x = [<span style="color: #8b2252;">"a"</span>]; y = [<span style="color: #8b2252;">"a"</span>]

puts <span style="color: #8b2252;">"x=x:</span><span style="color: #a0522d;"> #{same?(x,x)}</span><span style="color: #8b2252;">"</span>
puts <span style="color: #8b2252;">"x=y:</span><span style="color: #a0522d;"> #{same?(x,y)}</span><span style="color: #8b2252;">"</span>
</pre>
</div>

<pre class="example">
x=x: true
x=y: false
</pre>
</section>


</section>
<section>
<section id="sec-3" >

<h2>oo semantics and object identity</h2>
<div class="org-src-container">

<pre  class="fragment">sugababes = <span style="color: #228b22;">Set</span>.new [<span style="color: #008b8b;">:mutya</span>, <span style="color: #008b8b;">:keisha</span>, <span style="color: #008b8b;">:siobhan</span>]
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment">sugababes.delete(<span style="color: #008b8b;">:siobhan</span>); sugababes.add(<span style="color: #008b8b;">:heidi</span>) <span style="color: #b22222;"># </span><span style="color: #b22222;">2001</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment">sugababes.delete(<span style="color: #008b8b;">:mutya</span>); sugababes.add(<span style="color: #008b8b;">:amelle</span>) <span style="color: #b22222;"># </span><span style="color: #b22222;">2005</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment">sugababes.delete(<span style="color: #008b8b;">:keisha</span>); sugababes.add(<span style="color: #008b8b;">:jade</span>) <span style="color: #b22222;"># </span><span style="color: #b22222;">2009</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment">new_band = <span style="color: #228b22;">Set</span>.new [<span style="color: #008b8b;">:mutya</span>, <span style="color: #008b8b;">:keisha</span>, <span style="color: #008b8b;">:siobhan</span>] <span style="color: #b22222;"># </span><span style="color: #b22222;">2011</span>
</pre>
</div>
</section>

</section>
<section>
<section id="sec-4" >

<h2>what do we really want from equality?</h2>
</section>
<section id="sec-4-1" >

<h3>ONE equality operator!</h3>

</section>
<section id="sec-4-2" >

<h3>equivalence relation</h3>
<ul class="org-ul">
<li>talk about definition, and equivalence classes, and the problem
of making fine/coarse distinctions
</li>
</ul>

</section>
<section id="sec-4-3" >

<h3>x=y =&gt; f(x)=f(y) for arbitrary f</h3>

</section>
<section id="sec-4-4" >

<h3>useful &amp; important to be able to compare compound values</h3>
<p>
eg http requests &#x2013; "is this in my cache"?
</p>

</section>
<section id="sec-4-5" >

<h3>useful &amp; important to distinguish different objects with same current value</h3>

</section>
<section id="sec-4-6" >

<h3>useful &amp; important to have a single equality predicate to perform these jobs</h3>
<ul class="org-ul">
<li>putting arbitrary items into maps (memoizing, caching)
</li>
</ul>

</section>
<section id="sec-4-7" >

<h3>in java.util.List terms&#x2026;</h3>
<ul class="org-ul">
<li><code>==</code> is sometimes too fine
</li>
<li><code>.equals()</code> is sometimes too coarse
</li>
</ul>
</section>

</section>
<section>
<section id="sec-5" >

<h2>solution: egal</h2>
</section>
<section id="sec-5-1" >

<h3>works everywhere</h3>

</section>
<section id="sec-5-2" >

<h3>examples</h3>
</section>
<section id="sec-5-2-1" >

<h4>mutable objects</h4>

</section>
<section id="sec-5-2-2" >

<h4>immutable objects</h4>

</section>
<section id="sec-5-2-3" >

<h4>immutable objects with references to mutable components</h4>
</section>
</section>
<section>
<section id="sec-6" >

<h2>implications</h2>
</section>
<section id="sec-6-1" >

<h3>immutability matters</h3>
</section>
<section id="sec-6-1-1" >

<h4>immutable views on mutable objects don't cut it</h4>

</section>
<section id="sec-6-2" >

<h3>mutable lists &amp; sets are rubbish</h3>
</section>
<section id="sec-6-2-1" >

<h4>lose much of the utility of having a compound if you can't easily compare it</h4>
</section>
</section>
<section>
<section id="sec-7" >

<h2>questions for discussion</h2>
</section>
<section id="sec-7-1" >

<h3>reference equality isn't perfect for mutable objects</h3>
<aside class="notes">
<p>
conflict: can't have reference equality and the ability to simulate other objects
</p>
</aside>

</section>
<section id="sec-7-2" >

<h3>laziness</h3>
</section>
<section id="sec-7-3" >

<h3>abstract data types &amp; user-defined equality</h3>
</section>
<section id="sec-7-3-1" >

<h4>classic problem with cached hashcode field as a perf optimization</h4>
</section>
<section id="sec-7-4" >

<h3>closures and data defined using them</h3>
</section>
<section id="sec-7-4-1" >

<h4>applies equally to anonymous inner classes</h4>
</section>
</section>
<section>
<section id="sec-8" >

<h2>what is the problem?</h2>
<p>
Why does equality matter?
</p>

</section>
<section id="sec-8-1" >

<h3>too fine a distinction? too coarse?</h3>
<p>
numbers &#x2013; EQ
</p>

<p>
strings
</p>

<p>
"<code>EQ</code> is often too fine, and <code>EQUAL</code> is often too coarse"
</p>

<p>
equality of lists, sets, maps
</p>

</section>
<section id="sec-8-2" >

<h3>map lookup</h3>
<p>
map lookup depends on your equality relation
</p>

<p>
in Lisp, you need <code>EQL</code> for numbers but <code>EQUAL</code> for strings
</p>

<p>
this prevents the creation of a single map that takes arbitrary
keys
</p>

<p>
(useful for generic memoizing function)
</p>

</section>
<section id="sec-8-3" >

<h3>reference equality</h3>
<p>
do <code>x</code> and <code>y</code> refer to the same location (i.e. object) in memory?
</p>

<p>
(this doesn't even make sense for some <code>x</code> and <code>y</code>, such as
primitive <code>int</code> and <code>float</code> values)
</p>
</section>
<section id="sec-8-4" >

<h3>value equality</h3>
<p>
do <code>x</code> and <code>y</code> have the same value?
</p>

<p class="fragment">
(at this moment in time)?
</p>

</section>
<section id="sec-8-5" >

<h3>bitwise equality</h3>
<p>
reference equality for pointers
</p>

<p>
value equality for primitive types
</p>

<p>
Java's <code>==</code>, Lisp's <code>EQ</code>, Ruby's <code>equal?</code>
</p>

<p class="fragment">
efficiently maps to native machine instructions
</p>

<p class="fragment">
semantically problematic
</p>

</section>
<section id="sec-8-6" >

<h3>user-defined equality</h3>
<p>
give every object an <code>equal</code> method that the user can override
</p>
</section>
<section id="sec-8-7" >

<h3>operational equivalence</h3>
<p>
can I distinguish <code>x</code> and <code>y</code> by calling methods on them?
</p>

<p>
<i>extensional equivalence</i>
</p>

<p>
(oppose <i>intensional equivalence</i>)
</p>

<p>
black box vs white box
</p>
</section>
<section id="sec-8-8" >

<h3>identity of indiscernables</h3>
<p>
If there's no way to tell the difference between \(x\) and \(y\), then
\(x = y\)
</p>
<p class="fragment">
if \(x\) is a pink unicorn and \(y\) is a green unicorn, they are not
the same, because \(x\) is pink and \(y\) is not pink
</p>
<p class="fragment">
what about the <i>invisible pink unicorn</i>?
</p>

<aside class="notes">
<p>
(we know that she is invisible, because we can't see her; we have faith that she is pink)
</p>

<p>
the invisible pink unicorn is indiscernible from the invisible green unicorn
</p>

<p>
therefore, they are the same thing
</p>
</aside>

</section>
<section id="sec-8-9" >

<h3>pedagogical example</h3>
</section>

</section>
<section>
<section id="sec-9" >

<h2>aside: equivalence relation</h2>
<p>
reflexive:
</p>

<p>
$$ a \equiv a $$
</p>

<p>
symmetric:
</p>

<p>
$$ a \equiv b \implies b \equiv a $$
</p>

<p>
transitive:
</p>

<p>
$$ a \equiv b \land b \equiv c $$
</p>

<p>
$$ \implies a \equiv c $$
</p>

<p>
Partitions the universe into <i>equivalence classes</i>
</p>
</section>
<section id="sec-9-1" >

<h3>symmetry causes particular problems for inheritance</h3>
<p>
If \(B\) is a subclass of \(A\), and \(A \equiv B\), does \(B \equiv A\)?
</p>
</section>
</section>
</div>
</div>
<script src="./lib/js/head.min.js"></script>
<script src="./js/reveal.min.js"></script>
<script>

        		// Full list of configuration options available here:
        		// https://github.com/hakimel/reveal.js#configuration
        		Reveal.initialize({
        			controls: true,
        			progress: true,
        			history: true,
        			center: true,
                                slideNumber: true,
        			rollingLinks: false,
        			keyboard: true,
        			overview: true,
        			 // slide width
        			 // slide height
        			 // slide margin
        			minScale: 1.20, // slide minimum scaling factor
        			maxScale: 1.20, // slide maximum scaling factor


        			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        			transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none
        			transitionSpeed: 'default',

        			// Optional libraries used to extend on reveal.js
        			dependencies: [
        				{ src: './lib/js/classList.js', condition: function() { return !document.body.classList; } }
        				,{ src: './plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }
        				,{ src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }
        				,{ src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        				,{ src: './plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
        				,{ src: './plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        				// { src: './plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
        				// { src: './plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
         				
        			]
        		});
</script>
</body>
</html>
